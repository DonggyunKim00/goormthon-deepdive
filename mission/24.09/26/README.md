## 1️⃣ 재귀 함수란?

- 함수가 **자기 자신을 호출하는 것**을 **재귀 호출** 이라 한다.
- 재귀 함수는 자기 자신을 호출하는 행위, 즉 **재귀 호출을 수행하는 함수**를 말한다.
- 재귀 함수를 사용하면 반복되는 처리를 반복문 없이 구현 가능!!
- 재귀 함수는 자신을 무한으로 재귀 호출 하므로 재귀 함수 내에는 재귀 호출을 멈출 수 있는 **탈출 조건이 필수 이다!!**

```abap
🔥 **재귀 함수 TIP** 🔥

- 재귀적으로 생각하지 말 것!
	- 머릿속에 함수 실행 순서를 그리려고 하지 말자
	- 처음부터 큰 그림을 머릿속에 그리려고 하지 않는다
	- 재귀 함수의 중요한 부분들에만 초점을 좁히자!

- 재귀의 4단계 접근법
	1. **재귀를 꼭 써야 하는가?**
		- '반복문 대신 재귀를 써야하는가?' 를 생각하기
		- 재귀적인 자료구조(연결리스트,트리,그리드 등)나 풀이 공식(팩토리얼, 피보나치 등)이 있을때 사용
		- 변수 선언 없이 코딩 하고 싶을때 ==> 함수형 프로그래밍(불변성)
	2. **베이스 조건 찾기**
		- 베이스 조건이란? '더이상 자기 자신을 호출하지 않게 하는 조건' === 재귀가 끝나는 조건
		- 단순한 작업으로, 바로 답을 구할 수 있는, 가장 쉬운 상황
		- 베이스 조건에서 return 해야 될 값은 **문제에서 요구한 답의 데이터 타입!**
	3. **분해**
		- 함수를 호출할 때마다 베이스 조건에 가까워지도록 인풋값을 조작
		- 계속 분해하다보면 우리가 원하는 베이스 조건에 도달해야 한다.
	4. **조합**
		- 조합은 재귀 호출이 베이스 조건에 걸려 멈추고 난 후 일어나는 작업들
		- 부분 답을 가지고 전체 답을 구하는 방법을 생각
		- 조합을 어떻게 할까?
			1. 베이스 조건 바로 위의 단계를 생각해보기
			2. 베이스 조건의 3단계 위를 생각해보기
			3. 위의 두 케이스의 공통점을 찾기
		- 일단 믿기 => 바로 아랫단계의 재귀 호출에서 정답을 반환해준다고 가정하는 것
```

- 팩토리얼 예제는 가장 대표적인 재귀함수 예제이다.
  ![스크린샷 2024-09-26 오후 11.28.28.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8b6f698e-8a67-4ad1-94b0-53ee956264c9/149209d8-d547-4463-91ce-6ea7bdaed490/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.28.28.png)
  ![스크린샷 2024-09-26 오후 11.38.33.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8b6f698e-8a67-4ad1-94b0-53ee956264c9/09b7e230-f4d8-4bda-8a1b-6ebaa4840900/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-26_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.38.33.png)

  ```jsx
  // 1. 팩토리얼 반복문으로 처리하는 예제
  const factorial = (n) => {
    if (n <= 1) return 1;

    let res = n;
    while (--n) {
      res *= n;
    }

    return res;
  };

  console.log(factorial(3)); // 6
  console.log(factorial(5)); // 120

  // 2. 팩토리얼 재귀함수로 처리하는 예제
  const factorial = (n) => {
    // 탈출 조건: n이 1 이하일 때 리턴
    if (n <= 1) return 1;

    return n * factorial(n - 1);
  };

  console.log(factorial(3)); // 6
  console.log(factorial(5)); // 120
  ```

## 2️⃣ 백트래킹이란?

- **그래프, 트리의 모든 원소를 완전 탐색** 하기 위한 목적으로 사용
- **해를 찾는 도중 해가 절대 될 수 없다고 판단되면, 되돌아가서 해를 다시 찾아가는 기법**
- 모든 가능한 경우의 수 중에서 **특정한 조건을 만족하는 경우만 살펴보는 것**
- 주로 **DFS(깊이우선탐색)** 알고리즘을 사용하여 구현
  ⇒ 🚨 BFS가 아닌 DFS를 사용하는 이유는 조건에 부합하지 않으면 이전 수행으로 돌아가야 하기때문!

```abap
📝 DFS vs BFS 📝

- BFS(너비우선탐색 알고리즘)
	- 로직 💿
		1. 시작 정점 방문
		2. 시작 정점에 인접한 모든 정점들을 우선 방문
		3. 더이상 방문할 정점이 없으면 한 depth를 내려가서 다시 인접한 정점 방문
	- 장점 👍
		1. 답이 되는 경로가 여러개인 경우에도 최단 경로임을 보장함
		2. 최단 경로가 존재하면 한 경로가 무한히 깊어져도 최단 경로를 반드시 찾을 수 있음
		3. 노드 수가 적고 깊이가 얕은 해가 존재할 때 유리함
	- 단점 👎
		1. 큐를 이용해 다음에 탐색할 노드들을 저장하여 노드가 많을수록 메모리가 많이 든다.
		2. 노드의 수가 늘어나면 탐색해야 하는 노드가 많아져서 비효율적

- DFS(깊이우선탐색 알고리즘)
	- 로직 💿
		1. 시작 정점을 방문
		2. 자식을 모두 탐색
		3. 연결된 노드가 존재하지 않을때까지 들어오면 한 단계 이전으로 돌아가 알고리즘 수행
	- 장점 👍
		1. BFS에 비해 저장공간의 필요성이 적다. 백트래킹을 해야하는 노드들만 저장해주면 된다.
		2. 찾아야하는 노드가 깊은 단계에 있을 수록, 그 노드가 좌측에 있을 수록 BFS보다 유리하다.
	- 단점 👎
		1. 답이 아닌 경로가 매우 깊다면, 그 경로에 깊이 빠질 우려가 있다.
		2. 찾은 해가 최단 경로라는 보장이 없다.
```

- 백트래킹 과정
  1. DFS 등으로 모든 경우의 수를 탐색
  2. 조건문을 걸어 답이 절대로 될 수 없는 상황을 정의
  3. 조건문에 걸린 경우 탐색을 중지하고 이전으로 돌아가서 다른 경우를 탐색
- 백준 15649 (N과 M)

```jsx
const fs = require('fs');

const filePath = process.platform === 'linux' ? '/dev/stdin' : 'input.txt';
const input = fs
  .readFileSync(filePath, 'utf8')
  .toString()
  .trim()
  .split(' ')
  .map(Number);

const dfs = (N, M, result = []) => {
  if (result.length === M) {
    console.log(result.join(' '));
    return;
  }

  for (let i = 1; i <= N; i++) {
    if (!result.includes(i)) dfs(N, M, [...result, i]);
  }
};

const solution = (N, M) => {
  dfs(N, M);
};

const [N, M] = input;
solution(N, M);
```

### 📚 REFERENCE

- 모던 자바스크립트 DEEP DIVE 12.7.2장 재귀함수
- https://velog.io/@eddy_song/you-can-solve-recursion
- https://velog.io/@hyerani/JavaScript-알고리즘-백트래킹BackTracking
- https://velog.io/@vagabondms/DFS-vs-BFS
