## 1️⃣ 클래스란?

- ES6 에서 도입된 문법으로서 프로토타입을 이용하여 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 새로운 객체 생성 매커니즘을 제시하는 것
- **사실 클래스는 함수이다.**
  → 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕
- 하지만 클래스는 `extends`, `super` 키워드 등으로 상속 관계를 더욱 간결하고 명료하게 하기때문에 단순한 문법적 설탕이라고 보기보단 **새로운 객체 생성 매커니즘**으로 보는것이 좋다

```abap
📌 클래스 vs 생성자 함수 📌

- 두 문법 모두 프로토타입 기반의 인스턴스를 생성함 하지만 아래와 같은
	차이점이 존재한다.

- 차이점
	1. 클래스는 new 연산자 없이 호출하면 에러 발생
		 생성자 함수를 new 연산자 없이 호출하면 일반 함수로서 호출
	2. 클래스는 상속을 지원하는 extends, super 키워드를 제공
	3. 클래스는 let,const와 같이 TDZ(일시적 사각 지대)가 존재하기
		 때문에 호이스팅이 되지 않는 것 처럼 보임
		 생성자 함수는 정의된 방식에 따라 변수 or 함수 호이스팅이 발생함
	4. 클래스 내의 모든 코드에는 암묵적으로 strict mode 가 지정됨
	5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두
		 [[Enermerable]]의 값이 false 이기때문에 열거할 수 없음!
```

## 2️⃣ 클래스 정의

- `class` 키워드를 사용하여 정의함
- 클래스의 이름은 생성자 함수와 마찬가지로 파스칼 케이스를 사용하는 것이 일반적임
- 클래스는 일급 객체이다.
- 클래스의 몸체에는 0개 이상의 메서드만 정의 가능
- 정의할 수 있는 메서드 종류
  - **constructor (생성자)**
    - 인스턴스를 생성하고 초기화 하기 위한 특수한 메서드
    - 클래스 정의가 평가되면 `constructor`의 기술된 동작을 하는 함수 객체가 생성된다!!
    - 클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티는 서로 관련이 없음!
    - `constructor` 는 클래스 내에 최대 한개만 존재 가능
    - `constructor` 생략 시 클래스는 빈 `constructor`에 의해 빈 객체를 생성함
      ⇒ 빈 constructor 암묵적 정의
    - 인스턴스를 생성항때 초기값을 전달하면 constructor의 매개변수에 전달된다.
    - 별도의 반환문을 가져서는 안된다. ⇒ 암묵적으로 this(인스턴스)를 반환하기 때문
  - **프로토타입 메서드**
    - 인스턴스로 호출 해야함!
    - prototype 프로퍼티에 메서드를 추가하지 않아도 됨
      ⇒ 클래스 몸체 내부에서 정의가능
    - 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.
    - 인스턴스 프로퍼티를 참조할 수 있음 (constructor에 정의된 프로퍼티)
    - 클래스로 생성한 인스턴스의 프로토타입
      아래 사진에 따라`class`로 생성한 인스턴스는 메서드를 참조해서 사용할 수 있음
          ![스크린샷 2024-09-24 오후 9.40.06.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8b6f698e-8a67-4ad1-94b0-53ee956264c9/68d85248-3c48-4512-899b-c4c6818b7e8a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.40.06.png)
  - **정적 메서드**
    - 클래스로 호출 해야함!
    - 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
    - 클래스 내의 메서드에 `static` 키워드를 붙이면 정적 메서드가 됨
    - 인스턴스 프로퍼티를 참조할 수 없음 (constructor에 정의된 프로퍼티)
    - 정적 메서드의 프로토타입 체인
      ![스크린샷 2024-09-24 오후 9.42.01.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8b6f698e-8a67-4ad1-94b0-53ee956264c9/3b861a73-eba2-4243-be1b-be4cb471543b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.42.01.png)
  ```jsx
  class Person {
    // constructor(생성자)
    constructor(name) {
      // 인스턴스 생성 및 초기화
      this.name = name; // 여기서 name 프로퍼티는 public
    }

    // 프로토타입 메서드
    sayHi() {
      console.log(`Hi my name is ${this.name}`);
    }

    // 정적 메서드
    static sayHello() {
      console.log('hello!');
    }
  }

  // 인스턴스 생성
  const me = new Person('donggyun');

  // 인스턴스의 프로퍼티 참조
  console.log(me.name); // donggyun

  // 프로토타입 메서드 호출
  me.sayHi(); // Hi my name is donggyun

  // 정적 메서드 호출
  Person.sayHello(); // hello!
  ```

## 3️⃣ 인스턴스 생성

- 클래스는 생성자 함수이며, `new` 연산자와 함께 호출되어 인스턴스를 생성함
- 클래스는 인스턴스를 생성하는 것이 유일한 존재 이유이므로 반드시 `new` 연산자와 함께 호출해야 한다!

```jsx
// 클래스 선언문
class Person {}

const me1 = new Person();
console.log(me); // Person {}

const me2 = Person(); // TypeError

// 클래스 표현식
// 클래스 이름 MyClass는 함수와 동일하게 클래스 몸체 내부에서만 유효한 식별자!
// 클래스 표현식에서 사용한 클래스 이름은 외부에서 참조 불가능!
const Something = class MyClass {};
const s1 = new Something();
const s2 = new MyClass(); // ReferenceError
```

## 4️⃣ 클래스의 인스턴스 생성 과정

1. **인스턴스 생성과 this 바인딩**
   - `new` 연산자와 함께 클래스를 호출하면 빈 객체(완성되지 않은 인스턴스) 생성
   - 위에서 생성한 인스턴스의 프로토타입으로 클래스의 `prototype` 프로퍼티가 가리키는 객체 설정
   - 인스턴스가 `this`에 바인딩됨 ⇒ `constructor` 내부의 `this`는 클래스가 생성한 인스턴스를 가리키게 됨
2. **인스턴스 초기화**
   - `constructor` 내부 코드가 실행되어 `this`에 바인딩되어 있는 인스턴스 초기화
   - 이때, 프로퍼티를 추가하고 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 값을 초기화함
   - (`constructor`가 생략되었다면 이 과정이 생략됨)
3. **인스턴스 반환**
   - 인스턴스가 바인딩된 `this`(인스턴스)가 암묵적으로 반환

### 📚 REFERNECE

- 모던 자바스크립트 DEEP DIVE 25장 클래스
