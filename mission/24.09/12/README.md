## ❓클로저란❓

- **함수와 함수가 선언된 어휘적 환경(렉시컬 환경)의 조합**
  - 함수가 선언된 렉시컬 환경? ( 가장 중요하다고 생각함! )
  - 렉시컬환경이란 아래 예제와 같이 함수가 선언된 환경에 따라 달라지는 것
  ```jsx
  // 예제 1
  // inner 함수의 정의가 outer 함수의 내부에 있음
  const x = 1;

  function outer() {
    const x = 10;
    function inner() {
      console.log(x); // 10
    }
    inner();
  }

  outer();

  // 예제 2
  // inner 함수의 정의가 outer 함수의 외부에 있음
  const x = 1;

  function outer() {
    const x = 10;
    inner();
  }

  function inner() {
    console.log(x); // 1
  }
  outer();
  ```
- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 ⇒ **외부 함수의 생명 주기가 끝**나도 **외부 함수의 변수를 중첩함수가 참조**할 수 있는 것!!
  - 이때 외부 함수가 종료 됐는데 어떻게 내부 함수가 외부 함수의 변수를 참조할 수 있지?
  ```abap
  💡**실행 컨텍스트**와 **렉시컬 환경**

  - 실행 컨텍스트의 구조
  	- **환경 레코드**: 호출된 함수에서 선언된 변수, 함수의 정보
  	- **외부 렉시컬 환경**(상위 스코프): 외부 렉시컬 환경의 환경레코드 + 외부 렉시컬 환경

  - 스코프
  	- 스코프의 실체는 **실행 컨텍스트의 렉시컬 환경**이다!
  	- 렉시컬 환경은 자신의 외부 렉시컬 환경에 대한 참조를 통해 상위 렉시컬 환경과 연결된다!
  		=> (스코프 체인)

  - 렉시컬 스코프란?
  	- 함수가 정의된 위치에 따라서 외부 렉시컬 환경의 참조가 결정 되는 것!!
  	- 이때 외부 렉시컬 환경(상위 스코프)의 참조는 내부 슬롯 [[Environment]] 에 저장됨!

  - 내부 슬롯이란?
  	- 함수가 정의된 환경과 호출되는 환경이 다를수 있는데, 이때 해당 함수의 상위 스코프를 계속 기억하고
  		있어야 한다! 따라서 함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경(상위 스코프)
  		의 참조를 저장한다!
  	- 상위 스코프가 함수 객체의 내부 슬롯에 저장되므로 함수 객체가 존재하는 한 상위 스코프를 참조 하고
  		있다는 뜻이다.
  		=> 즉, 내부 슬롯이 없어질때까지(== 상위 스코프를 참조하고 있는 함수가 사라질때까지)
  			 상위 스코프는 사라지지 않는다는 뜻이다!
  			(+ 메모리의 참조가 일어나고 있으므로 GC의 대상이 아니게됨)

  - 🔥결론🔥
  	- 위의 내용을 종합해 봤을때 실행 컨텍스트는 실행 컨텍스트 스택에 쌓이면서 수명을 다한 실행 컨텍스트
  		가 없어지게 되는데, 이때 실행 컨텍스트는 스택에서 없어 지더라도 내부에 갖고 있던 렉시컬 환경이
  		중첩 함수의 내부 슬롯으로부터 참조되면서 살아 남았기때문에 수명이 다한 외부함수의 변수를 내부함수가
  		사용할 수 있게 된다!
  ```

## 📝 클로저 예제

1️⃣

1. 전역 렉시컬 환경 생성(환경레코드+외부 렉시컬 환경(null))
2. 환경 레코드 window에 counter 함수 객체 생성
3. `counter` 함수 객체의 상위 스코프가 전역 렉시컬 환경이므로 내부 슬롯에 전역 렉시컬 환경을 상위 스코프로서 저장

2️⃣

1. `counter` 함수를 호출
2. `counter` 함수의 렉시컬 환경 생성 ⇒ 1️⃣에서 `counter` 함수 객체의 내부슬롯에 저장된 전역 렉시컬 환경을 `counter` 함수 렉시컬 환경의 외부 렉시컬 환경에 할당
3. 중첩 함수 `up()`과 `getCount()`가 평가(이 두 함수는 화살표 함수이므로 런타임에서 평가된다)
4. 중첩 함수 객체 `up()`과 `getCount()`는 자신의 내부슬롯에 외부 렉시컬 환경(상위 스코프)인 `counter` 렉시컬 환경의 참조를 할당한다.

3️⃣

1. `counter` 함수 종료되면 실행 컨텍스트 스택에서 제거
2. 이때 전역에 선언한 `const count = counter();` 가 count 함수 객체를 참조 하고 있다.
   (따라서 전역에서 counter 함수 객체의 반환값인 `up`, `getCount`가 참조되고있고, `up`과 `getCount` 함수 객체의 내부 슬롯이 counter 함수의 렉시컬 환경을 참조하고 있으므로 GC의 대상이 아니게 된다!)
3. `counter` 함수가 반환한 `up()`과 `getCount()`를 호출하면 각 함수에 대한 실행 컨텍스트가 생기고 실행 컨텍스트 스택에 푸쉬된다.
4. `up()`과 `getCount()`의 렉시컬 환경에 외부 렉시컬 환경의 참조로는 3️⃣-2 에서 각 함수 내부 슬롯에 할당 되었던 참조(counter 렉시컬 환경)가 할당된다.

📚 : `count.count` 는 함수 객체를 생성했을때의 그 상태 그대로를 복사한 것 이므로 실행 컨텍스트와 렉시컬 환경과는 관련이 없다!

```jsx
// 1️⃣
function counter() {
  let count = 0;

  const up = () => {
    count += 1;
  };

  const getCount() => {
	  return count;
  }

  return {
    count,
    up,
    getCount
  };
}

// 2️⃣
const count = counter();
// 3️⃣

console.log(count.count); // 0
console.log(count.getCount()); // 0
count.up();
count.up();
console.log(count.count); // 2
console.log(count.getCount()); // 4
```

### 참고 자료

- 모던 자바스크립트 딥다이브 24장 클로저
- https://velog.io/@jangsebari/렉시컬-환경-Lexical-Environment
- https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures
